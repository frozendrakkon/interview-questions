# JavaScript

1. ### Какие типы данных есть в javaScript?

   - в JS есть примитивные типы данных и объекты (ссылочный тип).  Примитивные: _Boolean, number, string, undefuned, null, BigInt, Symbol._ Объекты: _Objects_

2. ### Что такое переменные?

   - Переменные - это "хранилище для данных". Переменная имеет выделенную область памяти и собственное имя.
   - Имена переменных могут содержать(**\$** и **\_** ). Переменные не могут начинаться с цифр и еще они регистрозависимые.

3. ### В чем отличия var, let, const?

   - Главное отличие var от let в их области видимости. У var область видимости функциональная. Область видимости let блочная, проще говоря ограничена фигурными скобками, в котором она объявлена.
   - Также если мы попытаеся обратиться к переменной до ее инициализации с var мы получим _undefined_, с let/const _ReferenceError_
   - Отличия let и const в том, что мы можем переинициализировать(мутировать) let, а const мы можем инициализировать только 1 раз.

4. ### Что такое функция

   - Функция - это разновидность _объекта_, которая используется для выполнения сложных алгоритмов поставленной задачи. Объявить функции можно двумя способами
     1. Function expression
     2. Function declaration

5. ### В чем отличия Function expression и Function declaration

   > Моментом создания

   - Javascript объявляет и инициализирует Function declaration, до того, как начнется выполнение самой первой строчки кода - поэтому мы можем обратиться к Function declaration, до ее инициализации. Function expression создается в тот момент, когда выполнение кода дойдет до нее, если мы попробуем обратиться к ней до этого момента, то получим _ReferenceError_

   > Методом объявления

   ```javascript
   function test1() {
     console.log("Look me"); // Function declaration
   }

   const test2 = () => {
     console.log("Look me again!"); //Function expression
   };
   ```

   > У стрелочных функций нет arguments и this
   - Если происходит обращение к this, его значение берётся снаружи. Если к arguments - вернется ReferenceError: arguments is not defined

    ```js
    let group = {
      title: "Our Group",
      students: ["John", "Pete", "Alice"],

      showList() {
        this.students.forEach((student) => alert(this.title + ": " + student));
      },
    };

    group.showList();
    /*Если бы мы использовали «обычную» функцию, была бы ошибка: */
    ```

    - Отсутствие this естественным образом ведёт к другому ограничению: стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с new.

   > Создание конструктора
    - Function Declaration может легко создавать конструкторы объектов, в то время как _стрелочная функция не может создавать конструкторы_

6. ### что такое hoisting (всплытие/поднятие)?

   - это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.
   - _Объявление переменной через var всегда обрабатывается до выполнения кода_

     ```javascript
     bla = 2;
     var bla;
     // ...
     // читается как:
     var bla;
     bla = 2;
     ```

   - _Важно отметить, что подъем будет влиять на объявление переменной, но не на инициализацию ее значения. Значение присваивается при выполнении оператора присваивания:_

   - _все необъявленные переменные это по факту глобальные переменные._

     ```javascript
     function hoist() {
       a = 20;
       var b = 100;
     }

     hoist();

     console.log(a);
     // Доступ как к глобальной переменной вне функции hoist()
     //Выводит: 20
     console.log(b);
     /* Как только b была назначена, она заключена в рамки области видимости функции hoist(). Что означает то, что мы не можем вывести её за рамки функции.
     Вывод: ReferenceError: b is not defined */
     ```

7. ### что такое замыкание?

- "Замыкание" - это способность функции запоминать переменные, которые были определены внутри родительской функции, даже после того, как родительская функция была выполнена.

  ```javascript
  // 1
  function outerFunction() {
    const outer = `I see the outer variable!`;
    function innerFunction() {
      console.log(outer);
    }
    return innerFunction;
  }
  outerFunction()(); // I see the outer variable!

  // 2
  function person() {
  let name = 'Peter';
  
  return function displayName() {
    console.log(name);
    };
  }
  person() // 'Peter'
  ```

10. ### что такое рекурсия?

- Рекурсия - это один из приемов в программировании, когда функция вызывает саму себя. В рекурсии должны присутствовать:

  1. базис рекурсии - это условие, при котором рекурсия завершает свое выполнение
  2. шаг рекурсии - это действие, которое будет выполняться до тех пор, пока не достигнет базиса рекурсии.

  ```javascript
  function pow(x, n) {
  if (n === 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
  }
  alert( pow(2, 3) ); // 8
  ```

11. ### что добавили в ES6, чем вы пользуетесь из добавленного?

- стрелочные функции
- Деструктурирующее присваивание

  ```js
  const names = ['sergei', 'maksim', 'roman']
  const [sergei, maksim, roman] = names
  console.log(sergei) // sergei
  ```

  - шаблонные литералы(обратные кавычки), в которых мы можем использовать выражения. (`${выражение}`)

  ```js
  console.log(`Мне ${15 + 6} год`) // мне 21 год
  ```

  - Классы (Classes).
  - Блочная область видимости (ключевые слова «let» и «const»).
  - Symbol
  - Параметры по умолчанию.

  ```js
  const test = (a = 2) => a 
  test() // 2
  ```

- добавлены promise
- оператор возведения в степень \*\*
- метод _Array.prototype.includes_, который проверяет, содержится ли переданный аргумент в массиве.
- асинхронность теперь официально поддерживается (async/await);
- «висячие» запятые в параметрах функций. Добавлена возможность ставить запятые в конце списка аргументов функций;
- spread и rest оператор

  ```js
  // rest
  const test = (a, b, ...numbers) => {
    console.log(a, b, numbers)
  }
  test(1, 2, 3, 4, 5, 6) // 1, 2, [3,4,5,6]

  // spread
  let arr = [3, 5, 1];
  alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
  ```

12. ### Что такое ошибка undefined

- это значит, что мы не присвоили значение переменной

13. ### Что такое глобальные переменные, какие проблемы могут быть с ними связаны?

- Глобальные переменные - переменные, которые объявлены вне какого-либо блока, и их область видимости весь скрипт. Из-за этого могут возникуть проблемы с инициализацией и перезаписью переменных

14. ### В чем отличия === и == ?

    Строгое сравнение(===) проверяет равенство без приведения типов. Например если сравнить ““ и false, то результат строгого неравенства будет false,а если сравнивать не строгим, то true

15. ### Что такое null?

    - null - это тип примитив, который представляет отсутствие какого-либо объектного значения. null часто присутствует в местах где ожидается объект, но подходящего объекта нет.

16. ### Что такое методы?

    - Метод - это встроенная функция, которая есть у каждого типа данных(Кроме null, undefined), доступных через точку. Метод упрощает работу с данными. Важно! Примитивные типы данных не имеют методов и свойств! Когда мы обращаемся к свойству строки (например length), js под капотом
    создает объектную обертку и наследует свойства и методы от глобального объекта String, который имеет метод length

17. ### что такое свойства функций?

    - Функции содержат полезные свойства, которые можно использовать. Например мы можем узнать имя функции с помощью .name, или количество параметров с помощью length. Также пользователь может помещать в функции свои свойства, к которым можно обратиться. Переменная это не свойство

18. ### Что такое анонимные функции?

    - Анонимная функция - это функция, который была объявлена без собственного имени

19. ### какие есть методы у массивов

    - forEach() - выполняет указанную функцию один раз для каждого элемента в массиве
    - reduce() - применяет функцию к каждому элементу массива, возвращая одна результирующее свойство.
    - map() - создает новый массив с результатом вызова функции для каждого элемента массива
    - split() - разбивает объект String на массив строк путём разделения строки указанной подстрокой.
    - splice() - изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
    - join() - объединяет все элементы массива (или массивоподобного объекта) в строку.
    - concat() - возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.
    - filter() - выполняет указанную функцию для каждого элемента в массиве, и возвращает новый массив с элементами, которые прошли проверку
    - reverse() - изменяет порядок элементов в массиве на обратный
    - sort() - сортирует на месте массив и возвращает его. Порядок cортировки по умолчанию соответствует порядку кодовых точек Unicode.

20. ### Что такое Объект?

    - _Объекты – это_ ассоциативные массивы с рядом дополнительных возможностей.
    - _Чтобы получить доступ к значение объекта_, мы можем обратиться к значению через точку или через квадратные скобки. Квадратные скобки позволяют взять ключ из переменной
    - _Все объекты в JavaScript являются потомками_ глобального объекта Object; все объекты наследуют методы и свойства из прототипа объекта Object.prototype, хотя они и могут быть переопределены. Например, прототипы других конструкторов переопределяют свойство constructor и предоставляют свои собственные методы toString(). Изменения в объекте прототипа Object распространяются на все объекты до тех пор, пока свойства и методы, учитывающие эти изменения, не переопределяются дальше по цепочке прототипов.
    - _Объект используется для хранения_ коллекций различных значений. Свойства объекта - это пара ключ-значение. Объект можно создать двумя способами:
    - _для удаления свойства объекта_ можем использовать оператор _delete_

    ```javascript
    let user = new Object(); // синтаксис "конструктор объекта"
    let user = {}; // синтаксис "литерал объекта"
    ```

21. ### Можно ли изменить содержимое объекта, если объявление произошло через const?

    - Объект можно изменить, если он объявлен через константу. _const защищает от изменений только саму переменную, но не ее содержимое_

22. ### Можем ли мы получить свойство в объекте, которого не существует?

    - Да. В отличии от других языков js может получить доступ к любому свойству. При обращении к свойству, которого нет, вернется undefined.

23. ### Как мы можем проверить существование свойства в объекте?

    - С помощь оператора _in_, мы можем проверить существует ли свойство.
    - Мы можем сравнить свойство с undefined, но это не всегда вернет верный результат(в том случае если свойства имеет значение undefined)

24. ### Упорядочены ли свойства объектов?

    - свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.

25. ### Как js понимает, что нужно удалить объект? какие методы используются для этого?

    - js постоянно анализирует, что находиться у него в памяти - js удаляет недостижимые объекты - сборка мусора
    - Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
    - Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.
    - Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.
    - сборка мусора происходит автоматически, мы не можем повлиять на нее

26. ### Что такое конструктор объекта?

    - обычный синтаксис литерала {...} позволяет создать только один объект. Но _зачастую нам нужно создать множество однотипных объектов_, таких как пользователи, элементы меню...
    - Это можно сделать при помощи _функции-коструктора_ и оператора _new_
    - Функции конструкторы являются обычными функциями, но есть 2 соглашние - Имя функции должно начинаться с большой буквы. Функция-коструктор должна вызываться при помощи оператора _new_
    - Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в this, который в итоге станет результатом.
    - Но если return всё же есть, то применяется простое правило: _При вызове return с объектом, будет возвращён объект, а не this._ _При вызове return с примитивным значением, примитивное значение будет отброшено._

27. ### как мы можем проверить функция вызвана с помощью _new_, или нет?

    - Мы можем проверить это с помощью свойства _new.target_ внутрии функции.
    - В случае, если функция вызвана при помощи new, то в new.target будет сама функция, в противном случае undefined.
    - Синтаксис опциональной цепочки ?. имеет три формы:
    - obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
    - obj?.\[prop] – возвращает obj\[prop], если существует obj, и undefined в противном случае.
    - obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.

28. ### Что такое опциональная цепочка "?" ?

    - Опциональная цепочка ?. — это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.
    - Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если часть перед ?. имеет значение undefined или null.

    ```js
    let user = {}; // пользователь без адреса

    alert(user?.address?.street); // undefined (без ошибки)
    ```

29. ### Отличия объектов от примитивных типов данных?

    - Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке». Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.

    ```javascript
    let user = { name: "Иван" };

    let admin = user;

    admin.name = "Петя"; // изменено по ссылке из переменной "admin"

    alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"
    ```

    ```javascript
    let a = {};
    let b = a; // копирование по ссылке

    alert(a == b); // true, т.к. обе переменные ссылаются на один и тот же объект
    alert(a === b); // true
    ```

    ```javascript
    let a = {};
    let b = {}; // два независимых объекта

    alert(a == b); // false
    ```

30. ### Какие методы есть у Объектов

    - _Object.assign(dest, [src1, src2, src3...])_ - копирует свойства всех исходных объектов в целевой объект. Важно! этот метод не делает глубокое клонирование объекта.

      ```javascript
      let user = { name: "Иван" };

      let permissions1 = { canView: true };
      let permissions2 = { canEdit: true };

      // копируем все свойства из permissions1 и permissions2 в user
      Object.assign(user, permissions1, permissions2);

      // теперь user = { name: "Иван", canView: true, canEdit: true }
      ```

    - _Object.keys(obj)_ - Возвращает массив, содержащий имена всех собственных перечислимых свойств переданного объекта.
    - _Object.create(proto[, propertiesObject])_ - создаёт и возвращает новый объект с указанным прототипом и свойствами.

      ```javascript
      const obj = {
        sega: 19,
        adi: 18,
      };
      const newObj = Object.create(obj);
      console.log(newObj);
      ```

    - _Object.freeze()_ - замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.

    - _Object.is(value1, value2)_ - определяет, являются ли два значения одинаковыми значениями.

      ```javascript
      Object.is("foo", "foo"); // true
      Object.is(window, window); // true

      Object.is("foo", "bar"); // false
      Object.is([], []); // false

      var test = { a: 1 };
      Object.is(test, test); // true

      Object.is(null, null); // true

      // Специальные случаи
      Object.is(0, -0); // false
      Object.is(-0, -0); // true
      Object.is(NaN, 0 / 0); // true
      ```

31. ### Что такое ООП?

    - Объектно ориентированное программирование - это парадигма разработки программных систем, в которой приложения состоят из объектов.

32. ### 4 Парадигмы ООП, и что они значат

    - Инкапсуляция - защищает данные и код от внешнего вмешательства. Благодаря этому отсуствует риск, когда одна функция может взаимодействовать на другую без нашего ведома.
    - Наследование - с помощью наследования один объект может приобретать свойства другого
    - Полиморфизм - Возможность дополнять объект функционалом. Возможность выступать объекту в разных формах. Классический полиморфизм — замещение, переопределение методов.
    - Абстракция — в ООП это придание объекту характеристик, которые четко выделяет его на фоне остальных, определяя его концептуальные границы.

33. ### Что делает цикл for in, и чем он опасен?

    - цикл for in пробегает по ключам и свойствам объекта и выполняет функцию описанную в теле цикла. Если в объекте нет свойств, то цикл игнорируется.
    - цикл for in опасен тем, что он пробегает не только по ключам и свойствам, но и заходит в его прототип, это может привести к проблемамч

34. ### что происходит со старым значением в переменной, после того как мы ее переопределили?

    - при переопределении переменной, старое значение удаляется

35. ### как называются языки программирования, в которых мы можем не связывать типы данных с переменной?

    - язык программирование в котором мы можем не связывать тип данных с переменной называется _динамически типизированным_

36. ### Как будет вести себя результат вычисления, если где-то в выражении будет NaN?

    - если где-то в расчете будет NaN, то результатом вычислений с его участием будет NaN.

37. ### Как работает оператор запятая?

    - оператор запятая (,) - предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего. оператор запятая имеет низкий приоритет, следовательно нужно использовать скобки

38. ### чему равно сравнение null == undefined? что можете рассказать об этом сравнении?

    - для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому null == 0 ложно.

39. ### Как сравниваются строки?

    - Строки сравниваются посимвольно в лексикографическом порядке

40. ### Какие логические операторы есть в js? как они работают?

    - в js, есть 3 логических оператора - || (или), && (и), ! (не)
    - оператор || - запинается на правде (result = a || b;), если все операторы ложные, то возвращается последний из них
    - оператор && - запинается на лжи ()

41. ### что такое "use strict"

    - use strict - это строгий режим в js

42. ### Что вы можете рассказать про оператор "??"

    - Оператор "??" был добавлен совсем недавно - из двух аргументов он возвращает, тот у которого значение определено (null/undefined он отсеивает). У него низкий приоритет,
      поэтому для его использования скорее всего потребуются скобки. Также этот оператор нельзя использовать с операторами _||, &&_, но можно обойти это ограничение с помощью скобок.

43. ### как называется повторение шага в цикле?

    - итерация

44. ### Как можно завершить цикл, или перейти к следующей итерации цикла?

    - для завершения цикла используется break, для того, чтобы перейти к следующей итерации используется continue

    ```js
    for (let i = 0; i < 10; i++) {
      // если true, пропустить оставшуюся часть тела цикла
      if (i % 2 == 0) continue;

      alert(i); // 1, затем 3, 5, 7, 9
    }
    ```

    - нельзя использовать break/continue справа от оператора "?"

45. ### Как можно выйти из нескольких уровней цикла?

    - Для выхода из нескольких уровней цикла используются _метки_ - метка имеет вид идентификатора с двоеточием перед циклом.

    ```js
    outer: for (let i = 0; i < 3; i++) {

    for (let j = 0; j < 3; j++) {

        let input = prompt(Значение на координатах (${i},${j}), '');

        // если пустая строка или Отмена, то выйти из обоих циклов
        if (!input) break outer; // (*)

        // сделать что-нибудь со значениями...
    }
    }
    alert('Готово!');
    ```

    - Вызов break/continue возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.
    - Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.

46. ### Что вы можете рассказать о конструкции switch case?

    - Конструкция switch заменяет собой сразу несколько if.

    ```js
    switch(x) {
      case 'value1':  // if (x === 'value1')
        ...
        [break]

      case 'value2':  // if (x === 'value2')
        ...
        [break]

      default:
        ...
        [break]
    }
    ```

    - Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее. Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch). Если ни один case не совпал – выполняется (если есть) вариант default
    - Несколько вариантов case, использующих один код, можно группировать.

    ```js
    switch (a) {
      case 4:
        alert("Правильно!");
        break;

      case 3: // (*) группируем оба case
      case 5:
        alert("Неправильно!");
        alert("Может вам посетить урок математики?");
        break;
      default:
        alert("Результат выглядит странновато. Честно.");
    }
    ```

47. ### Что происходит с внешней переменной, если в функции мы объявляем переменную с таким же именем

    - Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.

48. ### Что такое параметр по умолчанию, как его задать?

    - параметр по умолчанию - это значение параметра, используемое функцией, если значения параметра не было передано. Мы можем присвоить параметр по умолчания, когда объявляем параметры.

      ```js
      function(a, b = 0) {}
      ```

    - В данном случае _b = 0_ это число, но на его месте могло бы быть и более сложное выражение, которое бы вычислялось и присваивалось при отсутствии параметра. Например:

      ```js
      function showMessage(from, text = anotherFunction()) {
        // anotherFunction() выполнится только если не передан text
        // результатом будет значение text
      }
      ```

49. ### Если параметр не указан, то его значение?

    - undefined

50. ### Что произойдет если использовать return без значения?

    - Пустой return аналогичен return undefined. _Он приведет к немедленному выходу из функции!_

51. ### Почему не следует добавлять перенос строки между return и его значением?

    - потому что код не выполнится, _js подставит точку с запятой после return._ Но можно осуществить перенос с помощью скобки после _return_

52. ### функция это значение?

    - да, функция это значение, и мы можем работать с ней как со значением - копировать функцию в другую переменную, передавать в качестве параметра и т.д

53. ### Что такое callback функция?

    - коллбэк функция(функция обратного вызова) - функция, которая передается как аргумент другой функции.

    ```js
    const parent = (func) => {
      func()
    }
    const params = () => {
      console.log(123)
    }
    parent(params) // 123
    ```

56. ### Что такое транспилер и полифил?

    - Частенько приходится поддерживать браузер, который не поддерживает всех функций js для этого есть инструмент, который преобразует ваш новый код в более старые эквиваленты кода. Этот процесс обычно называют “transpiling”
    - Слово polyfill - обозначает принятие определения новой функции и создания части кода , эквивалентного поведению, но способного работать в older JS environments(старой среде js).

57. ### Какие методы вы используете для чистоты кода?

    - Использование простых, но понятных имен для переменных или функций.
    - не использовать абстрактные названия - data, value...
    - использовать одинаковое форматирование кода (prettier)
    - не создавать функции, которые реализуют несколько действий
    - стараться писать код таким образом, чтобы он не требовал комментариев - код сам должен быть комментарием

58. ### Что такое линтер?

    - линтер - это инструмент статического анализа кода для выявления проблемных шаблонов, обнаруженных в коде JavaScript. Он приводит код к более-менее единому стилю, помогает избежать глупых ошибок, умеет автоматически исправлять многие из найденных проблем и отлично интегрируется со многими инструментами разработки

59. ### Принципы SOLID

    - S single responsebility (принцип единой ответственности)
    - O open-closed (принцип открытости-закрытости)
    - L liskov substition (принцип подсановки Барбары Лисков)
    - I interface segregation (принцип разделение интерфейса)
    - D dependency inversion (принцип инверсии зависимостей)

60. ### что такое кроссбраузерность

    - Кроссбраузерность - это когда сайт отображается и работает во всех частоиспользуемых браузерах одинаково.

62. ### Что такое HTTP, какие у него есть методы?

    - HyperText Transfer Protocol (HTTP) - протокол передачи данных, благодаря которым пользователь получает доступ к веб-ресурсам
    - одни из самых частоиспользуемых методов (GET, POST, DELETE )
  
63. ### Что такое Json

    - Javascript Object Notation(json) - Формат обмена и хранения данных, основанной на javascript.

65. ### Что такое Ajax

    - Asynchronous Javascript and XML(Ajax) - это набор методов для веб-разработки, которые позволяют веб-приложением работать асинхронно - обрабатывать любые запросы в фоновом режиме

66. ### Что такое a11y

    a11y(Accessibility Testing) - доступность, для людей с ограниченным возможностями к информации.

67. ### Что такое symbol?

    - symbol - примитивный тип данных, который создает уникальный примитив
    - Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
    ```js
    let user = {
      name: "Вася",
    };

    let id = Symbol("id");

    user[id] = 1;

    alert(user[id]); // мы можем получить доступ к данным по ключу-символу

    const obj = {};
    const sym = Symbol();
    obj[sym] = 'foo';
    obj.bar = 'bar';
    console.log(obj); // { bar: 'bar' }
    console.log(sym in obj); // true
    console.log(obj[sym]); // foo
    console.log(Object.keys(obj)); // ['bar']

    object.keys() // не вернет ключ symbol.
    ```

68. ### Можем ли мы сделать symbol с двумя одинаковыми именами единой сущностью?

    - да, с помощью _Symbol.for(key)._

    ```js
    let id = Symbol.for("id");
    let idAgain = Symbol.for("id");
    alert(id === idAgain); // true
    ```

    - Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт undefined.

69. ### как преобразуется объект?

    - объект преобразуется сначала в примитивы, а затем выполняется операция.

70. ### можем ли мы повлиять на преобразование объекта

    - _Мы можем повлиять на то, как объект будет преобразовываться_ при помощи методов.
    - Существует всего 3 типа преобразований (хинтов):
    - "string" (для alert и других операций, которым нужна строка)
    - "number" (для математических операций)
    - "default" (для некоторых операций)

71. ### Что такое this

    - this(контекст выполнения) - отсылает нас на объект, в котором мы сейчас находимся.

    ```js
      console.log(this) //  OBJECT window
    ```

72. ### call, apply, bind, для чего они нужны?

    - Эти методы требуются для привязки контекста.  
    Отличия call от apply - в том, что в call мы передаем аргументы через запятую, а в apply массивом  
    Отличия call,apply от bind - в том, что методы call и apply сразу вызывают функцию, а  bind создает обертку над ней, которую мы можем уже вызвать.

73. ### Как работает прототипное наследование

    - В js существует _prototype_ и _proto_. Они оба являются _свойствами объекта_ объекта.

        ```js
        someObj.__proto__
        someObj.prototype
        ```

    - свойство **proto** есть у _всех_ объектов. _Если у нас есть примитив, и мы обращаемся к нему, как к объекту .__proto_/_, то в памяти создается временная объектная версия этого примитива._
        - _proto каждого ОДИНАКОГО ПО ТИПУ объекта РАВНЫ_. proto чисел равны, proto функций равны, и т.д
        - _proto разных по типу объектов, совершенно независимые разные объекты_
        - **любой объект в js создается с помощью класса-конструктора new**

        ```js
        let promise = new Promise(() => {}) // new Promise(...)
        let man = {} // new Object(...)
        ```

      - _любой класс или function имеет prototype_
      - _любой объект создаеттся с помощью класса или function_
      - _Каждый prototype - это независимый объект, с определенным набором свойств и методов => Object.prototype !== Promise.prototype!_
      - _proto любого объекта ссылается на prototype функции-конструктора, с помощью которого этот объект был создан._

      **Зачем же классу нужен прототип, а объекту прото?**

      - _классы нам нужны, чтобы делать однотипные объекты. Если мы попытаемся прочитать свойство объекта, либо вызвать его метод, а данного свойства или метода нет, то объект полезет искать его через ссылку proto в прототип класса, с помощью которого он был создан_

    ```js
        let promise = new Promise(() => {}) // Promise prototype
        let man = {} // Object prototype
        let users = [] // Array prototype
        let age = 18 // Number prototype
        let name = "sega" // String prototype
        class Animal {} // Function prototype
        const some = (() => {}) // Function prototype
        let channell = new Youtube() // Youtube prototype
    ```

    - Отсюда понимаем

    ```js
        let promise = new Promise(() => {}) // promise.__proto__ === Promise.prototype
        let age = 18 // age.__proto__ === Number.prototype
    ```

74. ### В чем отличие forEach от map?

    - Возвращаемое значение
    > map() выделяет память и сохраняет значение return. forEach() выбрасывает значение return и всегда возвращает undefined.

    ```js
      const myAwesomeArray = [1, 2, 3, 4, 5]
      myAwesomeArray.forEach(x => x * x)
      //>>>>>>>>>>>>>return value: undefined

      myAwesomeArray.map(x => x * x)
        //>>>>>>>>>>>>>return value: [1, 4, 9, 16, 25]
    ```

    - Возможность привязывать другие методы
    > Второе различие между этими методами: map() можно привязывать к другим методам -  reduce(), sort(), filter() и т.д. А вот forEach(), как вы можете догадаться, возвращается undefined.

    ```js
      const myAwesomeArray = [1, 2, 3, 4, 5]
      myAwesomeArray.forEach(x => x * x).reduce((total, value) => total + value)
      //>>>>>>>>>>>>> Uncaught TypeError: Cannot read property 'reduce' of undefined

      myAwesomeArray.map(x => x * x).reduce((total, value) => total + value)
      //>>>>>>>>>>>>>return value: 55

    ```

    - Изменчивость
    >map() возвращает совершенно новый массив с преобразованными элементами и тем же количеством данных. В случае forEach(), даже если он вернется undefined, он изменит исходный массив с помощью callback. Поэтому что map() опирается на неизменность и forEach() является мутатором.

    - Скорость исполнения
    > Что касается производительности, они немного отличаются. Ну, это зависит от разных вещей, таких как компьютер, объем данных и т.д. Во многих случаях forEach() медленнее map().

75. ### В чем разница между переменной , которая является: null, undefined?

    - undefined возвращается когда переменная объявлена, но в ней нет значения
    - null значение присваивания. Его можно назначить переменной как представление без значения.

76. ### Что вы можете рассказать о необъявленной переменной?

    - Область видимости необъявленной переменной - весь скрипт
    - в строгом режиме, вы не сможете задать значение переменной бех объявления

77. ### В чем разница между объектами хоста и собственными объектами?

    - Встроенные объекты - основные предопределенные объекты всегда доступны в JavaScript. String , Math , RegExp , Object , Function и т.д.
    - Объекты хоста - объекты, которые предоставляются например средой браузера window , XmlHttpRequest, DOM и т.д. Они отличаются от встроенных объектов, поскольку не во всех средах будут одни и те же объекты хоста.
    - Объекты пользователя - объекты, определенные в коде пользователем

78. ### Что такое тернарный оператор, почему он так называется

    - тернарный оператор - оператор "?", он так называется, потому что может применяться к 3 операндам. Его логика - Условие ? Ложь : правда. Запинается на правде

79. ### Объясните разницу между синхронными и асинхронными функциями

    - синхронные функции не ждут "своего часа", при запуске программы они выполняются, когда интерпретатор дойдет до них. Асинхронные функции ждут определенные события(клик, скролл), промежуток времени и т.д, чтобы начать свое выполнение.

80. ### что такое функции высшего порядка?

    - Это функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата

81. ### что такое promise?

    - Promise это объект, который был создан, чтобы упростить работу с асинхронными операциями в js.

      ```js
      let promise = new Promise(function (resolve, reject) {
        // функция-исполнитель (executor)
        // "певец"
      });
      ```

    - Функция, переданная в конструкцию new Promise, называется _исполнитель_ (executor). (что-то, что обычно требует времени),
    - аргументы resolve и reject – это колбэки
    - resolve(value) — если работа завершилась успешно, с результатом value.
    - reject(error) — если произошла ошибка, error – объект ошибки.

82. ### Как называются внутренние свойства Promise?

    - state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
    - result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error)

83. ### Расскажите о методах Promise

    - У Promise есть свои методы:
    - then - Наиболее важный и фундаментальный метод – .then. _Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно»_, и получает результат. _Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой»_, и получает ошибку.

      ```js
      promise.then(
        function (result) {
          /_ обработает успешное выполнение _/;
        },
        function (error) {
          /_ обработает ошибку _/;
        }
      );
      ```

    - catch - Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента, Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:

      ```js
      let promise = new Promise((resolve, reject) => {
        setTimeout(() => reject(new Error("Ошибка!")), 1000);
      });
      // .catch(f) это тоже самое, что promise.then(null, f)
      promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
      ```

    - finnaly - Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой. Обработчик, вызываемый из finally, не имеет аргументов. Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.

      ```js
      new Promise((resolve, reject) => {
        setTimeout(() => resolve("result"), 2000);
      })
        .finally(() => alert("Промис завершён"))
        .then((result) => alert(result)); // <-- .then обработает результат
      ```

84. ### Что вы можете рассказать про асинхронность?

    - js - это асинхронный, однопоточный язык программирования. Мы часто сталкиваемся с асинхронностью, когда пользуемся сайтами - например eventLoop, setTimeout...
    - Js не ждет, пока функция начнет свое выполнение, вместо этого он кладет ее в стек и вызовет, когда придет ее время(setTimeout, eventLoop..)

85. ### Что такое Async/Await

    - Async/await впервые появились в ES6, они нужны для того, чтобы упростить работу с промисами.
    - async - ставится перед функцией. Задача async всегда возвращать promise
    - Ключевое слово await ставиться внутри функции async и оно заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится.

      ```js
            async function f() {

                let promise = new Promise((resolve, reject) => {
                  setTimeout(() => resolve("готово!"), 1000)
                });

                let result = await promise; // будет ждать, пока промис не выполнится (*)

                alert(result); // "готово!"
              }

              f();
      ```

86. ### Что происходит с массивами, когда мы пытаемся их сложить?

    - Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, таким образом, здесь [] становится пустой строкой, \[1] становится "1", а \[1,2] становится "1,2".

87. ### Почему js не может работать напрямую с памятью компьютера?

    - Потому что js интерпретируемый язык, и за его выполнение отвечает браузер, который не дает возможность взаимодействовать на память компьютера напрямую

88. ### Что происходит, когда мы вводим url в адресную строку и нажимаем enter?

    - Браузер делает запрос к DNS с IP-адресом сервера(если его нет в кэше), который требуется найти
    - устанавливает соединение с сервером посредством протокола, скорее всего TCL (три рукопожатия)
    - после того как соединение было установлено, браузер отправляет HTTP запрос на получение контента сайта. 
    - В первую очередь приходит html, браузер его считывает и смотрит, что еще нужно подгрузить.


89. ### Что приходит с сервера первым html/css/js или все вместе?

     - Первым всегда приходит html разметка, далее браузер отправляет запросы на сервер, чтобы получить нужные картинки, js, css и т.д

90. ### В чем отличия неопределенной переменной и необъявленной?

     - Неопределенная переменная - это переменная, которую мы объявили, но на данный момент не содержит никакого значения
     - необъявленная переменная - это переменная, которая была формально не объявлена в доступной области видимости

91. ### Почему мы можем обратиться к свойству примитивного типа, ведь это примитив?

     - Js под капотом создает объект-обертку, который наследует все свойства и методы глобального объекта того типа данных, к которому мы обратились.

92. ### Как проверить число на NaN?

     - Существует несколько способов проверить число на NaN
        - Object.is()  
        - isNaN()  
        - Написать полифилл
     - Рекомендуется использовать 1 вариант, т.к он даст точный результат. Функция isNaN() слишком буквально сравнивает на NaN, например функция вернет true, если значение будет undefined, NaN, {}, 'someString'. Это происходит потому что значение приводится к числу, и оно является NaN

93. ### Как работает eventLoop?

     - Js асинхронный, однопоточный язык. То как работает асинхронность объясняет eventLoop.  
     - Когда движок начинает выполнение javascript кода, то синхронные операции он кладет в callStack, где они выполняются в порядке очереди. Если встречается асинхронная операция, то движок кладет её в микро/макро таски, в зависимости от типа асинхронной операции.
     - Далее, когда приходит время выполнения нашей асинхронной операции, движок перемещает нашу задачу в callStack, где она выполняется. Микротаски приоритетнее макротасок, поэтому они выполняются раньше. К микротаскам относятся промисы, а к макротаскам все остальное.

94. ### Что вы можете рассказать о генераторах и итераторах?

    - Обычная функция возвращает только одно значение, генераторы могут порождать множество значений одно за другим с помощь yield.

      ```js
      function* generateSequence() {
        yield 1;
        yield 2;
        return 3;
      }

      let generator = generateSequence(); // Object generator

      let one = generator.next();
      let two = generator.next();

      alert(JSON.stringify(one)); // {value: 1, done: false}
      alert(JSON.stringify(two)); // {value: 2, done: false}

      ```

    - итератор - это объект, который предоставляет метод next(), возвращающий следующий элемент последовательности {value: 1, done: false}

95. ### Что такое Map и Set?

    - Map и Set - Это коллекции данных.
      Set похож на массив, но таковым не является, одним из важных отличий в том, что элементы Set должны быть уникальными.  
      Map похож на объект, но отличительной чертой является то, что ключи в map могут быть любого типа.

96. ### Что такое webPack, какой опыт работы с ним вы имеете?

97. ### Сколько прототипов может иметь объект?
    Только 1. Но есть обходной путь - мы можем сделать цепочку наследований через __proto__

98. ### Что такое ошибка cors, способы обхода?
    Эта механизм, который предотвращает запросы, если заголовки на сервере были не настроены на принятие кросс-доменных запросов. Различные плагины, запуск браузера с отключенной защитой, настройка заголовков, использование прокси-сервера

99. ### Что такое детерминированная функция (Чистая функция)? 
    Это функция, которая при одном наборе входных параметров возвращает всегда один и тот же результат

100. ### Что такое CDN?
     это географически распределённая сетевая инфраструктура, обеспечивающая быструю доставку контента пользователям веб-сервисов и сайтов. CDN умеет кешировать, но могут быть проблемы, что контент на origin уже обновился, а CDN до сих пор отдает старые данные.

101. ### Что такое модель OSI? Модель OSI
     это абстрактная эталонная модель для проектирования сетевых взаимодействий. В этой модели присутствуют уровни взаимодействия. Привычная модель выглядит так Ethernet - IP - TCP -  SSL(TLS) - HTTP. Модель OSI делится на уровни
      1. Физический
      2. Канальный
      3. Сетевой
      4. Транспортный
      5. Сеансовый
      6. Представления
      7. Прикладной

102. ### Что такое сервис-воркер?
     сервис-воркер это скрипт, который браузер запускает в фоновом режиме, и не требует постоянного соединения с интернетом. Возможности сервис-воркера: кэширование страницы, отправка push уведомлений, синхронизация данных в фоновом режиме. Сервис-воркеры не имеют доступа к DOM, localStorage т.к имеют отдельный от основного потока JavaScript. Сервис-воркеры можно использовать только на сайтах с HTTPS-протоколом.

103. ### что такое веб-воркеры?
     веб-воркеры - это потоки, принадлежащие браузеру, благодаря им мы можем отдать выполнение тяжелой задачи, при этом не останавливая цикл событий. Проще говоря, браузер предоставляет нам возможность использования многопоточности.

104. ### Что такое GateWay и Backend-for-Frontend?
     Это паттерны проектирования, которые используются для обеспечения доступа к разным API. Для решения этой задачи создается прокси-сервер, на который фронтенд отправляет запросы, а прокси-сервер перенаправляет эти запросы по различным микросервисам.

105. ### Что такое SSE?
     Server-Sent-Event - это механизм, похожий на web-сокеты, который позволяет поддерживать соединение с сервером постоянно, но имеются важные различия: В SSE - однонаправленный поток данных, который идет с сервера, можно передавать только текст, используются обычный HTTP-request. SSE гораздо проще web-сокетов, предоставляет меньше функционала, но часто многим приложениям и не требуется вся мощь веб-сокетов. SSE имеет механизм из коробки для переподключения соединения, если оно было разорвано, в отличии от веб-сокетов

106. ### Что такое Web-socket?
     Веб-сокеты это механизм, который появился в 2011 году. Он используется для решения проблемы с мгновенной передачи информации сервер-клиент. Веб-сокеты позволяют организовать двухстороннюю связь с сервером. веб-сокеты не используют HTTP-протокол, у них есть свой.

107. ### Что такое TLS (SSL)
     это протокол шифрования или же протокол “3 рукопожатий”, который обеспечивает защищенную передачу данных. По-другому говоря это процесс, при котором клиент-сервер обмениваются данными друг с другом и “договариваются” на формат шифрования. Под капотом HTTP использует как раз TLS

108. ### Что за метод Object.create()?
     это метод, который создает объект на основе другого объекта

109. ### Что за метод Object.assign(target, source1, source2 ...)?
     это метод, который копирует все свойства из одного или нескольких переданных объектов в исходный (target).  Если мы пытаемся скопировать вложенный объект через Object.assign - вложенные объекты копируются по ссылке, и поэтому при изменении свойств вложенного объекта, он будет применяться и к новому и к старому, т.к там ссылка на один объект
     
110. ### Что за метод Object.prototype.hasOwnProperty()?
     возвращает булев тип, если объект имеет переданное свойство, как собственное, а не наследующее.

111. ### Что за метод Array.flat()?
     возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень

112. ### Как мы можем копировать глубоко объект?
     JSON.stringify + JSON.parse - но нужно быть осторожным, т.к JSON может удалять свойства, которые null/undefiend/func
     structuredClone(obj) - работает во всех современных браузерах

113. ### Что произойдет, если мы попытаемся скопировать глубоко вложенный объект, через Object.Assign()
     при глубоком копировании - если во вложенности существуют другие объекты, они будут скопированы как по ссылке, и при изменении в копии вложенного объекта, изменится и target объект

114. ###

115. ###

116. ###
